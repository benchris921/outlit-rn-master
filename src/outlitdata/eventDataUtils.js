/**
 * Useful constants and functions that support the validation and verification
 * of event-related data;
 *
 * @author Stanton Parham
 */

import { validateLocation, validateGeohash, encodeGeohash } from './geoUtils';

/** The structure of valid metadata in an event data object; */
const VALID_META_STRUCTURE = {
  /* location related keys */
  loc: [ // {number[]} a 2 element array representing latitude and longitude (REQUIRED)
    0.0, // {number} latitude
    0.0, // {number} longitude
  ],
  g: '', // {string} the geohash of the lat and lon (REQUIRED (generated by this API))

  /* gen info keys */
  title: '', // {string} the title of the event (REQUIRED)
  'private': false, // {boolean} whether or not the event is private (REQUIRED)
  creator: '', // {string} uid of the original creator (REQUIRED (generated by this API))

  /* time related keys */
  createdTime: new Date(), // {timestamp} when the event was created (should be in terms of the server time) (REQUIRED (generated by this API))
  startTime: new Date(), // {timestamp} when the event starts (should be normalized so that timezone differences won't matter) (REQUIRED)
                         // NOTE: if updating the start time also pass in the end time even if it does not change
  endTime: new Date(), // {timestamp} when the event ends (should be normalized so that timezone differences won't matter) (REQUIRED)
                       // NOTE: if updating the end time also pass in the start time even if it does not change
  hasEnded: false, // {boolean} whether or not the event has ended (REQUIRED (generated by this API))
                   // NOTE: if updating whether or not the event has ended also pass in the end time event if it does not change

  /* type-of-event keys */
  types: { // {object}
    drinks: false, // {boolean} whether or not this event is categorized as drinks
    food: false, // {boolean} whether or not this event is categorized as food
    social: false, // {boolean} whether or not this event is categorized as social
    sports: false, // {boolean} whether or not this event is categorized as sports
    music: false, // {boolean} whether or not this event is categorized as music
    arts: false, // {boolean} whether or not this event is categorized as arts
    religion: false, // {boolean} whether or not this event is categorized as religion
    club: false, // {boolean} whether or not this event is categorized as club
    greek: false, // {boolean} whether or not this event is categorized as greek
    other: false, // {boolean} whether or not this event is categorized as other
  },

  /* SUBCOLLECTIONS (only exist in Firestore)
      guests - holds a record of each user invited to the event (see VALID_GUEST_STRUCTURE below)
  */
};

/** The structure of valid details in an event data object; */
const VALID_DETAILS_STRUCTURE = {
  creator: '', // {string} uid of the original creator (REQUIRED (generated by this API))
  desc: '', // {string} a quick splurge on the event (MIGHT WANT TO LIMIT CHARACTERS)
  phoneNum: '', // {string} phone number for the event (SHOULD VALIDATE)
  website: '', // {string} link to the event's site (SHOULD VALIDATE)
  relativeCost: 0, // {number} small int (1-5) representing the num of dollar signs out of 5 this event would cost
  addr: { // {object} the physical address of the event (SHOULD VALIDATE)
    line1: '', // {string} the first address line
    line2: '', // {string} the second address line (if needed)
    city: '', // {string} the city
    state: '', // {string} the state
    zip: '', // {string} the zip code
  },

  // the fields below are probably going to need to be maintained as subcollections
  upvotes: 0, // {number} int representing the number upvotes for the event
  genderRatio: 0.0, // {number} percentage of males to females at the event
  avgAge: 0.0, // {number} float representing the average age of the people at the event
};

/** The minimum length of the title of an event; */
const TITLE_MIN_LENGTH = 1;
/** The maximum length of the title of an event; */
const TITLE_MAX_LENGTH = 80;
/** The length of a valid Firestore UID; */
const CREATOR_LENGTH = 28;
/** The minimum length of the description of an event; */
const DESC_MIN_LENGTH = 1;
/** The maximum length of the description of an event; */
const DESC_MAX_LENGTH = 500;
/** The regular expression describing valid phone numbers; */
const PHONE_NUM_REGEX = /^[0-9]{10}$/;
/** The regular expression describing valid URLs; */
const URL_REGEX = /(?:https?:\/\/)?(?:[\w]+\.)([a-zA-Z\.]{2,6})([\/\w\.-]*)*\/?/;
/** The minimum relative cost of an event; */
const COST_MIN = 0;
/** The maximum relative cost of an event; */
const COST_MAX = 5;

/**
 * Checks if the given value is a valid address;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid address
 */
function validateAddress(value) {
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    throw new Error('The .addr property is not an object.');
  }
  if (typeof value.line1 !== 'string') {
    throw new Error('The .addr.line1 property is not a string. It is required.');
  }
  if (typeof value.city !== 'string') {
    throw new Error('The .addr.city property is not a string. It is required.');
  }
  if (typeof value.state !== 'string') {
    throw new Error('The .addr.state property is not a string. It is required.');
  }
  if (typeof value.zip !== 'string') {
    throw new Error('The .addr.zip property is not a string. It is required.');
  }
  if (value.line2 !== undefined) {
    if (typeof value.line2 !== 'string') {
      throw new Error('The .addr.line2 property is not a string.');
    }
  }

  // check for any extra properties
  Object.keys(value).forEach((key) => {
    if (VALID_DETAILS_STRUCTURE.addr[key] === undefined) {
      const errMsg = 'Invalid key .' + key + ' in .addr object. ' +
        'Only the following properties are allowed in the .addr object: ' +
        'line1, line2, city, state, zip.'
      throw new Error(errMsg);
    }
  });
}

/**
 * Checks if the given value is a valid title;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid title
 */
function validateTitle(value) {
  if (typeof value !== 'string') {
    throw new Error('The .title property is not a string.');
  }
  if (value.length < TITLE_MIN_LENGTH || value.length > TITLE_MAX_LENGTH) {
    throw new Error('The title must be between ' + TITLE_MIN_LENGTH + ' and ' + TITLE_MAX_LENGTH + ' characters long.');
  }
}

/**
 * Checks if the given value is a valid privacy;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid privacy
 */
function validatePrivacy(value) {
  if (value !== true && value !== false) {
    throw new Error('The .private property is not a boolean.');
  }
}

/**
 * Checks if the given value is a valid creator;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid creator
 */
function validateCreator(value) {
  if (typeof value !== 'string') {
    throw new Error('The .creator property is not a string.');
  }
  if (value.length !== CREATOR_LENGTH) {
    throw new Error('The creator must be a valid Firestore UID.');
  }
}

/**
 * Checks if the given value is a valid created time;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid created time
 */
function validateCreatedTime(value) {
  const objType = Object.prototype.toString.call(value);
  const valueIsAFirestoreFieldValue = objType === '[object Object]';
  if (objType !== '[object Date]' && !valueIsAFirestoreFieldValue) {
    throw new Error('The .createdTime property is not a Date.');
  }
}

/**
 * Checks if the given value is a valid start time;
 *
 * @param {*} value the value to check
 * @param {Date} endTime the end time of the same event
 * @throws {Error} if the given value is not a valid start time
 */
function validateStartTime(value, endTime) {
  if (Object.prototype.toString.call(value) !== '[object Date]') {
    throw new Error('The .startTime property is not a Date.');
  }
  if (Object.prototype.toString.call(endTime) !== '[object Date]') {
    throw new Error('The start time should be before the end time, but the end time is not a Date.')
  }
  if (value > endTime) {
    throw new Error('The start time should be before the end time.');
  }
}

/**
 * Checks if the given value is a valid end time;
 *
 * @param {*} value the value to check
 * @param {Date} startTime the end time of the same event
 * @throws {Error} if the given value is not a valid end time
 */
function validateEndTime(value, startTime) {
  if (Object.prototype.toString.call(value) !== '[object Date]') {
    throw new Error('The .endTime property is not a Date.');
  }
  if (Object.prototype.toString.call(startTime) !== '[object Date]') {
    throw new Error('The end time should be after the start time, but the start time is not a Date.')
  }
  if (value < startTime) {
    throw new Error('The end time should be after the start time.');
  }
}

/**
 * Checks if the given value is a valid indication of whether or not the event has ended;
 *
 * @param {*} value the value to check
 * @param {Date} endTime the end time of the same event
 * @throws {Error} if the given value is not a valid indication of whether or not the event has ended
 */
function validateHasEnded(value, endTime) {
  if (value !== true && value !== false) {
    throw new Error('The .hasEnded property is not a boolean.');
  }
  if (Object.prototype.toString.call(endTime) !== '[object Date]') {
    throw new Error('Whether or not the event has ended depends on the end time, but the end time is not a Date.')
  }
  const eventReallyHasEnded = (new Date()) >= endTime;
  if (eventReallyHasEnded && !value) {
    throw new Error('The event has ended, but the .hasEnded property is set to false.');
  }
  if (!eventReallyHasEnded && value) {
    throw new Error('The event has not ended, but the .hasEnded property is set to true.');
  }
}

/**
 * Checks if the given value is a valid map of types;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid map of types
 */
function validateTypes(value) {
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    throw new Error('The .types property is not an object.');
  }
  Object.keys(value).forEach((type) => {
    validateType(type);
    if (value[type] !== true && value[type] !== false) {
      throw new Error('The .types.' + type + ' property is not a boolean.');
    }
  });
}

/**
 * Checks if the given value is a valid description;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid description
 */
function validateDescription(value) {
  if (typeof value !== 'string') {
    throw new Error('The .desc property is not a string.');
  }
  if (value.length < DESC_MIN_LENGTH || value.length > DESC_MAX_LENGTH) {
    throw new Error('The description must be between ' + DESC_MIN_LENGTH + ' and ' + DESC_MAX_LENGTH + ' characters long.');
  }
}

/**
 * Checks if the given value is a valid phone number;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid phone number
 */
function validatePhoneNumber(value) {
  if (typeof value !== 'string') {
    throw new Error('The .phoneNum property is not a string.');
  }
  if (!PHONE_NUM_REGEX.test(value)) {
    throw new Error('The phone number must be a valid 10 digit US phone number.');
  }
}

/**
 * Checks if the given value is a valid website;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid website
 */
function validateWebsite(value) {
  if (typeof value !== 'string') {
    throw new Error('The .website property is not a string.');
  }
  if (!URL_REGEX.test(value)) {
    throw new Error('The website must be a valid URL.');
  }
}

/**
 * Checks if the given value is a valid relative cost;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid relative cost
 */
function validateRelativeCost(value) {
  if (typeof value !== 'number') {
    throw new Error('The .relativeCost property is not a number.');
  }
  if (value < COST_MIN || value > COST_MAX) {
    throw new Error('The relative cost must be between ' + COST_MIN + ' and ' + COST_MAX + '.');
  }
}

/**
 * Checks if the given value is a valid event type;
 *
 * @param {*} value the value to check
 * @throws {Error} if the given value is not a valid event type
 */
function validateType(value) {
  if (typeof value !== 'string') {
    throw new Error('Each type must be a string.');
  }
  if (VALID_META_STRUCTURE.types[value] === undefined) {
    throw new Error('Invalid event type: ' + value);
  }
}

/**
 * Validates the given array of types;
 *
 * @param {string[]} types the array of strings to validate
 * @throws {Error} if any of the types are not valid
 */
function validateTypesArray(types) {
  if (!Array.isArray(types)) {
    throw new Error('types must be an array');
  }

  types.forEach((type) => {
    validateType(type);
  });
}

/**
 * Returns whether or not the given key identifies a metadata key;
 *
 * @param {string} key the key to check
 * @return {boolean} whether or not the given key identifies a metadata key
 */
function isMetaKey(key) {
  return VALID_META_STRUCTURE[key] !== undefined;
}

/**
 * Returns whether or not the given key identifies a detail key;
 *
 * @param {string} key the key to check
 * @return {boolean} whether or not the given key identifies a detail key
 */
function isDetailKey(key) {
  return VALID_DETAILS_STRUCTURE[key] !== undefined;
}

/**
 * Checks for all the fields required to create an event (excluding the
 * fields that are generated by the API);
 *
 * @param {Object} eventData the event data to check
 * @throws {Error} if any required fields are missing
 */
function checkForAllRequiredFields(eventData) {
  // check if any event data is given
  if (eventData === undefined) {
    throw new Error('Event data must be provided.');
  }

  // check if the coordinates are given
  if (eventData.loc === undefined) {
    throw new Error('No .loc property defined. A location must be provided for every event.');
  }

  // check if the title is given
  if (eventData.title === undefined) {
    throw new Error('No .title property defined. A title must be provided for every event.');
  }

  // check if the privacy is given
  if (eventData.private === undefined) {
    throw new Error('No .private property defined. A privacy must be provided for every event.');
  }

  // check if the start time is given
  if (eventData.startTime === undefined) {
    throw new Error('No .startTime property defined. A start datetime must be provided for every event.');
  }

  // check if the end time is given
  if (eventData.endTime === undefined) {
    throw new Error('No .endTime property defined. An end datetime must be provided for every event.');
  }
}

/**
 * Checks for any fields that should not be changed after initial event creation;
 *
 * @param {Object} eventData the event data to check
 * @throws {Error} if any fields are present that shouldn't be changed after initial creation
 */
function checkForImmutableAfterCreationFields(eventData) {
  // check if any event data is given
  if (eventData === undefined) {
    throw new Error('Event data must be provided.');
  }

  // check if the created time is being changed
  if (eventData.createdTime !== undefined) {
    throw new Error('The .createdTime property should not be changed after initial creation.');
  }
}

/**
 * Cancesl out all types that are not provided in the given map;
 *
 * @param {Object} types the types map
 */
function cancelOtherTypes(types, value) {
  if (Object.prototype.toString.call(types) === '[object Object]') {
    Object.keys(VALID_META_STRUCTURE.types).forEach((type) => {
      if (types[type] === undefined) {
        types[type] = false;
      }
    });
  }
}

/**
 * Validates a key's format;
 *
 * @param {string} key the key to validate
 * @param {*} value the actual value associated with the key
 * @param {Object} eventData the other data sent along with this key (needed if a key's validity depends on another)
 * @throws {Error} if the key's format is invalid
 */
function validateKeyFormat(key, value, eventData) {
  switch (key) {
    case 'addr':
      validateAddress(value);
      break;
    case 'loc':
      validateLocation(value);
      break;
    case 'g':
      validateGeohash(value);
      break;
    case 'title':
      validateTitle(value);
      break;
    case 'private':
      validatePrivacy(value);
      break;
    case 'creator':
      validateCreator(value);
      break;
    case 'createdTime':
      validateCreatedTime(value);
      break;
    case 'startTime':
      validateStartTime(value, eventData.endTime);
      break;
    case 'endTime':
      validateEndTime(value, eventData.startTime);
      break;
    case 'hasEnded':
      validateHasEnded(value, eventData.endTime);
      break;
    case 'types':
      validateTypes(value);
      break;
    case 'desc':
      validateDescription(value);
      break;
    case 'phoneNum':
      validatePhoneNumber(value);
      break;
    case 'website':
      validateWebsite(value);
      break;
    case 'relativeCost':
      validateRelativeCost(value);
      break;
    default:
      throw new Error('Invalid key in event data: ' + key);
  }
}

/**
 * Validates the given event data object;
 * Generates and attaches a geohash to the returned metadata;
 *
 * @param {Object} eventData the event data to validate
 * @throws {Error} if the format is invalid
 * @return {Object} an object containing two properties:
 *    .meta contains the metadata from the passed in event data
 *    .details contains the details from the passed in event data
 */
function validateAndSplitEventData(eventData) {
  const meta = {};
  const details = {};

  if (eventData === undefined) {
    throw new Error('Event data must be provided.');
  }

  // move each piece of data to either meta or details based on the keys
  // while checking its format
  Object.keys(eventData).forEach((key) => {
    const keyIsMeta = isMetaKey(key);
    const keyIsDetail = isDetailKey(key);
    if (keyIsMeta || keyIsDetail) {
      // first check the format of the key
      validateKeyFormat(key, eventData[key], eventData);
      // key could be meta, detail, or both, so add it to the split data accordingly
      if (keyIsMeta) {
        meta[key] = eventData[key];
      }
      if (keyIsDetail) {
        details[key] = eventData[key];
      }
    } else {
      throw new Error('Invalid key .' + key + ' in event data.');
    }
  });

  // generate any fields based on others
  // if there is a location
  if (eventData.loc !== undefined) {
    // then generate and attach geohash to meta
    meta.g = encodeGeohash(eventData.loc);
  } else {
    // delete .g cuz it's only supposed to be generated
    delete meta.g;
  }

  // if there is an end time
  if (eventData.endTime !== undefined) {
    // then generate and attach hasEnded value to meta
    meta.hasEnded = (new Date()) >= eventData.endTime;
  } else {
    // delete .hasEnded cuz it's only supposed to be generated
    delete meta.hasEnded;
  }

  return { meta, details };
}

export {
  validateTypesArray, checkForAllRequiredFields, validateAndSplitEventData,
  checkForImmutableAfterCreationFields, cancelOtherTypes,
};
